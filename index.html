<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8' />
	<meta http-equiv="X-UA-Compatible" content="chrome=1" />
	<meta name="description" content="IO Benchmark : Comparison of IO methods for OS X and Linux" />
	<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
	<title>IO Benchmark</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
	<header class="inner">
		<a id="forkme_banner" href="https://github.com/adityaramesh/io_benchmark">View on GitHub</a>

		<h1 id="project_title">IO Benchmark</h1>
		<h2 id="project_tagline">Comparison of IO methods for OS X and Linux</h2>

			<section id="downloads">
				<a class="zip_download_link" href="https://github.com/adityaramesh/io_benchmark/zipball/master">Download this project as a .zip file</a>
				<a class="tar_download_link" href="https://github.com/adityaramesh/io_benchmark/tarball/master">Download this project as a tar.gz file</a>
			</section>
	</header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
<section id="main_content" class="inner">
<h1><a name="motivation" class="anchor" href="#motivation"><span class="octicon octicon-link"></span></a>Motivation</h1>

<p>I work on machine learning projects that involve serializing and deserializing
large amounts of data. The IO can often be the chief bottleneck in the programs
that I write. Naturally, I wanted to determine the fastest methods for
sequentially reading, writing, and copying files on OS X and Linux. This series
of benchmarks was written towards this end.</p>

<p>This page briefly describes the methodology, and my observations based on the
results from the two machines on which I ran the benchmarks. I also quickly
threw up a <a
href="https://docs.google.com/a/adityaramesh.com/forms/d/1h2ogikCYrW3oCFjMJhWSoyZQ0NeyP3759JRquyjh-YM/viewform">Google
form</a> so people can run the benchmarks on different systems and share their
results. The form submissions are publicly viewable.</p>

<p>Before proceeding, I would like to warn you that I am by no means a systems
expert. I have tried to be cautious when writing the benchmarks, but it is very
possible that I got a few details wrong, or missed some others entirely. Feel
free to communicate to me any comments or suggestions that you have about the
project.</p>

<h1><a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>Overview</h1>

<p>All of the benchmarks rely on the test files generated by
<code>tools/make_data.rb</code>. The implementations of the benchmarks can be
found in the <code>src</code> directory. Some common IO wrapper functions, and a
copy of the <a href="https://github.com/adityaramesh/ccbase">CCBase</a> headers,
are found in the <code>include</code> directory.<p>

<p>Each benchmark tests a series of IO methods that perform the same task. Each
IO method is evaluated <code>num_trials</code> times for each file size in the
range defined in <code>tools/test_read.sh</code> or
<code>tools/test_write.sh</code>, where <code>num_trials</code> is defined in
<code>include/configuration.hpp</code>. For each IO method, the test function
defined in <code>include/test.hpp</code> prints out the following
information:</p>

<ul>
<li>The file size, in megabytes.</li>
<li>The name of the IO method used.</li>
<li>The mean completion time, in milliseconds.</li>
<li>The standard deviation, in milliseconds.</li>
</ul>

<p>You can access the raw results for the two machines on which I ran the
benchmarks <a
href="https://github.com/adityaramesh/io_benchmark/tree/master/results">here</a>.

<p>Each method used in the read benchmark counts the occurrences of
<code>needle</code> (set to <code>0xFF</code> in
<code>include/configuration.hpp</code>) as a check for correctness. To mitigate
the effects of caching, the test function also purges the page cache after each
method evaluation (see <code>purge_cache</code> in
<code>include/io_common.hpp</code> for how this is done). The write benchmark
writes a specified number of randomly-generated bytes to a destination file. The
last benchmark, which tests copying, does not need much explanation.</p>

<h1><a name="methods" class="anchor" href="#methods"><span class="octicon octicon-link"></span></a>Methods</h1>

<p>The IO methods can be segregated into two broad categories. Each IO method
either uses a buffer to read or write one chunk at a time within a loop, or uses
a special function to accomplish the same task. Methods in the first class fall
into one of three categories: synchronous IO, POSIX AIO, or lock-free
asynchronous IO using C++ atomics. Examples of IO methods in the second class
are <code>mmap</code>, <code>splice</code>, and <code>sendfile</code>, with the
latter two being Linux-specific. I did not use Linux AIO, because I found
earlier that it <a
href="https://stackoverflow.com/questions/20973754/linux-aio-poor-scaling">scales
very poorly</a>. To my knowledge, Linux AIO only works reliably for raw block
devices.</p>

<p>Each IO method also uses zero or more of the following optimizations (which,
in many cases, turn out to be pessimizations): direct IO, read ahead advice to
the OS (for reading and copying), and preallocation (for writing and copying).
Sometimes, there is more than one way to perform a particular optimization on
the target platform. In such cases, all possible combinations of the available
choices were tried. I omitted reporting the combinations that generally yielded
slower execution times across the entire range of file sizes.</p>

<h3><a name="read_optimizations" class="anchor" href="#read_optimizations"><span class="octicon octicon-link"></span></a>Read Optimizations</h3>

<p>On OS X, one can disable caching using <code>fcntl</code> with the
<code>F_NOCACHE</code> flag. On Linux, this is done by opening the file using
the <code>O_DIRECT</code> flag. Further information I found online suggested
that the IO buffer address and length should both be multiples of the page size,
and the request length should be a multiple of the file system's block size. I
used <code>posix_memalign</code> to accommodate for these constraints.</p>

<p>OS X offers two different kinds of read ahead optimizations via
<code>fcntl</code>: <code>F_RDAHEAD</code> and <code>F_RDADVISE</code>. Based on
available documentation, I gathered that the <code>F_RDADVISE</code> and
<code>F_RDAHEAD</code> are analogous to the <code>FADV_WILLNEED</code> and
<code>FADV_SEQUENTIAL</code> flags on Linux, respectively. The
<code>FADV_WILLNEED</code> flag initiates a non-blocking read of the specified
region into the page cache. Experiment has shown that <code>F_RDADVISE</code>
has a similar effect on OS X. On Linux, the <code>FADV_SEQUENTIAL</code> flag
doubles the size of the read ahead buffer.  Presumably, the
<code>F_RDAHEAD</code> flag does something similar on OS X, but the manual was
sparse on details.</p>

<h3><a name="write_optimizations" class="anchor" href="#write_optimizations"><span class="octicon octicon-link"></span></a>Write Optimizations</h3>

<p>On both OS X and Linux, one can preallocate a file before writing to it, in
order to accelerate IO. As with the other optimizations, OS X exposes this
interface via <code>fcntl</code> and the <code>F_PREALLOCATE</code> flag. Linux
has the <code>fallocate</code> and <code>ftruncate</code> functions, which do
slightly different things. Using the <code>posix_fallocate</code> function on
Linux is inadvisable, because glibc emulates the behavior (very inefficiently!)
even if the underlying file system does not support the operation. The
<code>ftruncate</code> function throws <code>EOPNOTSUPP</code> in this case, so
the programmer has the option of falling back to other approaches. Finally, <a
href="https://blog.mozilla.org/tglek/2010/09/09/help-wanted-does-fcntlf_preallocate-work-as-advertised-on-osx/">this</a>
Mozilla blog post warns that on OS X, <code>F_PREALLOCATE</code> need to be
followed by <code>truncate</code> in order to force the data to be written to
the file. I implemented both approaches in the benchmarks.</p>

<h3><a name="copy_optimizations" class="anchor" href="#copy_optimizations"><span class="octicon octicon-link"></span></a>Copy Optimizations</h3>

<p>OS X and Linux both allow you to copy files using a simple read-and-write
loop or <code>mmap</code>. Linux also has the <code>splice</code> and
<code>sendfile</code> functions, which should perform zero-copy file transfers
on recent versions of the kernel.</code>

<h1><a name="results" class="anchor" href="#results"><span class="octicon octicon-link"></span></a>Results</h1>

Before I discuss the results for the two systems on which I ran the benchmarks,
here is the complete list of read methods that I tried on OS X and Linux. All
buffer-based IO methods were evaluated using each of the following buffer sizes:
4 KB, 8 KB, 12 KB, 16 KB, 24 KB, 32 KB, 40 KB, 48 KB, 56 KB, 64 KB, 256 KB, 1024
KB, 4096 KB, 16384 KB, 65536 KB, and 262144 KB.

<pre><code>// OS X:
read_plain
read_nocache
read_rdahead
read_rdadvise
read_aio_nocache
read_aio_rdahead
read_aio_rdadvise
read_async_nocache
read_async_rdahead
read_async_rdadvise
read_mmap_plain
read_mmap_rdahead
read_mmap_rdadvise
// Linux:
read_plain
read_direct
read_fadvise
aio_read_direct
aio_read_fadvise
read_async_plain
read_async_direct
read_async_fadvise
read_mmap_plain
read_mmap_fadvise
</code></pre>

Here is the list of write methods:

<pre><code>// OS X:
write_plain
write_nocache
write_preallocate
write_preallocate_truncate
write_preallocate_truncate_nocache
async_write_preallocate_truncate_nocache
write_mmap
// Linux:
write_plain
write_direct
write_preallocate
write_truncate
write_direct_preallocate
write_direct_truncate
write_async_plain
write_async_direct
write_async_preallocate
write_async_truncate
write_async_direct_preallocate
write_async_direct_truncate
mmap_preallocate
mmap_preallocate_direct
mmap_preallocate
mmap_truncate_direct
</code></pre>

Finally, here is a list of the copy methods. Note that I avoided testing many
combinations of optimizations that I expected to perform poorly based on the
read and write results.

<pre><code>// OS X:
copy_plain
copy_nocache
copy_rdahead_preallocate
copy_rdadvise_preallocate
copy_mmap
// Linux:
copy_plain
copy_direct
copy_preallocate
copy_mmap_plain
copy_mmap_fadvise
copy_splice
copy_splice_preallocate
copy_splice_preallocate_fadvise
copy_splice_fadvise
copy_sendfile
copy_sendfile_preallocate
copy_sendfile_preallocate_fadvise
copy_sendfile_fadvise
</code></pre>

<!--
<p>Before compiling the benchmarks, you will need to set two environment variables.</p>

<ul>
<li>Set <code>CXX</code> to your desired C++11-conformant compiler.</li>
<li>Set <code>BOOST_INCLUDE_PATH</code> to the path containing the Boost header files.</li>
</ul><p>Afterwards, you can compile the benchmarks by running <code>rake</code>.</p>

<h1>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h1>

<p>The <code>tools</code> directory contains a set of scripts that you will need to run the
benchmarks. In order to run these scripts, you will need to type <code>chmod +x
tools/*</code>.</p>

<ul>
<li>The <code>tools/make_data.rb</code> script uses <code>dd</code> to create a set of files in the
<code>data</code> directory. These files are used to perform the benchmarks.</li>
<li>The <code>tools/test_read.sh</code> and <code>tools/test_write.sh</code> scripts perform the
reading and writing benchmarks, respectively.</li>
<li>The read benchmark <strong>must</strong> be run as root! This is because the benchmark
repeatedly drops the page cache to obtain accurate results. Do <strong>not</strong> run
this benchmark on a server that is doing anything important!</li>
<li>I did not create a script to run the copy benchmark. Based on existing
results, it is clear that the fastest way to copy a file on OS X is
<code>copy_mmap</code>, and <code>splice_preallocate_fadvise</code> or
<code>sendfile_preallocate_fadvise</code> on Linux.</li>
</ul><p>In both <code>test_read.sh</code> and <code>test_write.sh</code>, you will see the following lines:</p>

<pre><code>#sizes=(8 16 24 32 40 48 56 64 80 96 112 128 160 192 224 256 320 384 448 512 640 768 896 1024)
sizes=(8 16 32 64 80 96 112 256) #512 1024)
</code></pre>

<p>These lines declare the sizes of the files (in megabytes) that are used for the
benchmarks. By default, only a small set of files ranging in size from 8 MB to
256 MB are used. The first line in the pair refers to the full set of files
produced by <code>tools/make_data.rb</code>. Even on a machine with a fast PCIe SSD, the
read benchmark did not finish overnight. So only uncomment this line if you know
that you will be able to leave the benchmark running for a long time (half a day
to several days, depending on the speed of your hard drive).</p>

<p>The results of the benchmarks are saved in the <code>results</code> directory. This
directory already contains results generated from a couple of systems.</p>

<h1>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h1>

<p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="http://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Attribution 4.0 International
License"></a></p>

<p>This project is released under the <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0
International License</a>.</p>

<h1>
<a name="references" class="anchor" href="#references"><span class="octicon octicon-link"></span></a>References</h1>

<ul>
<li>The manual pages for <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/" title="Mac OS X Manual Pages">OS X</a> and <a href="http://linux.die.net/man/" title="Linux Manual Pages">Linux</a>.</li>
<li>A very useful <a href="https://github.com/Feh/write-patterns" title="Write Patterns">benchmark</a> on write patterns.</li>
<li>The <a href="http://blog.plenz.com/2014-04/so-you-want-to-write-to-a-file-real-fast.html" title="Write Patterns Blog Post">blog post</a> by the same author.</li>
<li>A Mozilla <a href="https://blog.mozilla.org/tglek/2010/09/09/help-wanted-does-fcntlf_preallocate-work-as-advertised-on-osx/" title="F_PREALLOCATE Blog Post">blog post</a> about <code>F_PREALLOCATE</code> on OS X.</li>
</ul>
-->
</section>
</div>

<!-- FOOTER	-->
<div id="footer_wrap" class="outer">
	<footer class="inner">
		<p class="copyright">IO Benchmark maintained by <a href="https://github.com/adityaramesh">adityaramesh</a></p>
		<p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
	</footer>
</div>

</body>
</html>
